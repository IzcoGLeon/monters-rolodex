{"version":3,"sources":["components/card/card.component.js","components/card-list/card-list.component.js","components/search-box/search-box.component.js","App.js","reportWebVitals.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsters","map","SearchBox","placeholder","handleChange","type","onChange","App","e","setState","searchField","target","value","state","fetch","then","response","json","users","this","filteredMonsters","filter","toLowerCase","includes","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"qTAMaA,G,MAAO,SAAAC,GAAK,OACvB,sBAAKC,UAAU,iBAAf,UACE,qBAAKC,IAAI,UAAUC,IAAG,+BAA0BH,EAAMI,QAAQC,GAAxC,4BACtB,mCAAML,EAAMI,QAAQE,QACpB,4BAAIN,EAAMI,QAAQG,aCgBTC,G,MAAW,SAAAR,GAAK,OAC3B,qBAAKC,UAAU,YAAf,SACGD,EAAMS,SAASC,KAAI,SAAAN,GAAO,OACzB,cAAC,EAAD,CAAuBA,QAASA,GAArBA,EAAQC,WCtBZM,G,MAAY,SAAC,GAAD,IAAEC,EAAF,EAAEA,YAAaC,EAAf,EAAeA,aAAf,OACvB,uBACEZ,UAAU,SACVa,KAAK,SACLF,YAAaA,EACbG,SAAUF,MCiECG,G,wDA7Db,aAAe,IAAD,8BACZ,gBAeFH,aAAe,SAACI,GACd,EAAKC,SAAS,CAACC,YAAYF,EAAEG,OAAOC,SAbpC,EAAKC,MAAQ,CACXb,SAAU,GACVU,YAAa,IANH,E,gEAYO,IAAD,OAClBI,MAAM,8CAA8CC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAAQF,MAAK,SAAAG,GAAK,OAAI,EAAKT,SAAS,CAACT,SAASkB,S,+BA0BpH,IAAD,EAC0BC,KAAKN,MAA9Bb,EADD,EACCA,SAAUU,EADX,EACWA,YACZU,EAAmBpB,EAASqB,QAAO,SAAA1B,GAAO,OAAIA,EAAQE,KAAKyB,cAAcC,SAASb,EAAYY,kBACpG,OACE,sBAAK9B,UAAU,MAAf,UACE,kDACA,cAAC,EAAD,CACEW,YAAY,kBACZC,aAAce,KAAKf,eAErB,cAAC,EAAD,CAAUJ,SAAUoB,W,GAnDVI,cCFHC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBZ,MAAK,YAAkD,IAA/Ca,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCAdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.bd58a66f.chunk.js","sourcesContent":["import React from 'react';\nimport './card.styles.css';\n\n//Exportamos nuestra const Card, que será un componente funcional (por función), que regresará un div. Como ya no tenemos al alcance el acceso a 'monster' (fuera del scope). Pasaremos 'monster' de la misma manera en que pasamos 'monsters' dentro de 'props' (en CardList) desde App.js. \n\n//Para la imagen utilizaremos una url donde se nos proprociona con distitnas imagenes variando el número solicitado en la URL, sin embargo en lugar de colocar un número específico usaremos una sintaxis ${props.monster.id} en la URL, ya que el id es un número único \nexport const Card = props => (\n  <div className='card-container'>\n    <img alt='monster' src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`}/>\n    <h2> {props.monster.name}</h2>\n    <p>{props.monster.email}</p>\n  </div>\n);","import React from 'react';\nimport { Card } from '../card/card.component'; //Importamos nuestro componente Card del que haremos uso dentro de este componente funcional CardList \nimport './card-list.styles.css';\n\n//Exportamos nuestro componente FUNCIONAL CardList, que por ahora solo contendrá un elemento div. Algo sobre los componentes es que toman algo llamado 'props'. 'Props' será el parámetro que obtendremos de nuestro componente funcional. \n\n//Prop será un objeto de cualquer propiedad que se escriba o declare en el componente donde sea usado\n//Una de las características que existen en el objeto Props es algo llamado 'children'. Siempre estará ahí pero si no hay un 'children' tendrá un valor null (App.js == H1). (H4) Ahora si renderizamos, en su lugar, props.children, podremos ver como se pasa esta propiedad dentro del <h1> que declaramos en App.js. \n\n// export const CardList = props => { \n//   console.log(props);\n//   return <div className='card-list'>{props.children}</div>;\n// };\n\n//(G2) Con esto ya no necesitamos children, en su lugar vamos a generar las cartas usando map(). Y no proviene de this.state sino de props, de ahí el cambio de this.state.monsters a props.monsters, ya que llamamos this.state.monsters en el componente CardList en uso en App.js como props. Sin embargo, de lo que Cardlist no se puede hacer responsable es de como se visualizará nuestro elemento del arreglo (entre <h1>). \n\n/* <div className='card-list'>\n{props.monsters.map(monster => (\n  <h1 key={monster.id}> {monster.name}</h1>\n))}\n</div> */\n\n// Como queremos que nuestro componente CardList no tenga que crear los elementos de imagen o de la carta, crearemos otro componente Card, CardList solo debería pensar que agregar, en que renderizar, no es como crearlo. \n\n//Debemos pasar 'monster' dentro del componente Card, después del componente Card (en su archvivo js) lo recibe ('monster') a través de 'props' y muestra el nombre.\n\nexport const CardList = props => ( \n  <div className='card-list'>\n    {props.monsters.map(monster => (\n      <Card key={monster.id} monster={monster}/>\n    ))}\n  </div>\n);","import React from 'react';\nimport './search-box.component.css';\n\n//Los componentes funcionales, a diferencia de los componentes de clase, no tienen acceso a State, ya que no tienen acceso a constructor() (el cual es un método de clase de Component -al que se extiende y que se importa de 'react-). De igual manera tampoco se tiene acceso de los métodos de ciclo de vida (lifecycle methods). No siempre es necesario disponer de métodos de ciclo de vida o de State ya que en ocasiones lo que querremos será renderizar solo HTML y eso es lo que un componente funcional hace. En pocas palabras un componente funcional es solo un componente al que se le pasan unos 'props' y regresa HTML.\n\n//Como vimos con la de-estructuración, también podemos realizar este mismo proceso de-estructurando 'props' fuera del objeto 'props', ya que cuando pasamos (props) se pasan como un solo objeto grande, así que se pasemos individualmente cada 'prop'. handleChange será el nombre bajo el que pasaremos la función (que declaramos dentro de input y -que antes era el atributo onChange- en App.js) para cambiar nustro state de acuerdo a los eventos sintéticos detonados por onChange\n\nexport const SearchBox = ({placeholder, handleChange}) => (\n  <input \n    className='search'\n    type='search' \n    placeholder={placeholder} \n    onChange={handleChange}\n    />\n);","import React, { Component } from 'react';\nimport { CardList } from './components/card-list/card-list.component'; //Importamos componente CardList\nimport { SearchBox } from './components/search-box/search-box.component';\nimport './App.css';\n\n//En versiones anteriores podríamos ver como se importan dos librerias: React y ReactDOM\n//Los componentes pueden ser construidos como funciones o como clases. Por default nos aparece una función con mombre App que regresa un bloque de HTML. Para un mayor entendimiento sobre como funciona esto ver Index.js\n\n//La razón por la que querríamos hacer uso de componentes por clases es porque nos da acceso a algo llamado state (estado). state es un tipo de objeto javascript con propiedades a las que podemos acceder en cualquier momento dentro de nuestra clase. La manera en la que hacemos esto es llamando el keyword constructor (A1)\n\n//En orden para poder escribir una clase se debe importar Component de React (import React, { Component } from ‘react’). Con esto podemos dar apertura y forma a nuestra clase:\n\n//Component es parte de la libreria de 'react' que arriba importamos, donde usamos la estructura { Component }, sin embargo si no lo importaramos de esa manera, aun asi podríamos usarlo cambiando la declaración en nuestra clase de Component por React.Component. Ej: class App extends React.Component \n\nclass App extends Component {\n  //(A2)\n  constructor() { //Dentro de constructor queremos llamar super\n    super(); //super llamará al método de constructor() en el componente de clase, lo que nos da acceso a this.state\n\n    //(KK2) Para ello, agregamos un campo a nuestro state que representará lo que el valor almacenado será. Lo llamaremos searchField y con un valor inicial de string vacio.\n    this.state = {\n      monsters: [],\n      searchField: ''\n    }; //Esta propiedad this.state ahora existe dentro de nuestra clase App y ahora podemos configurarla a algun valor. Configuramos una propiedad en nuestro objeto state\n\n    //La clase Component, que se extiende a la clase App, nos da el método llamado setState, y lo que este método nos permite hacer es modificar nuestro objeto state, en cada uno de nuestros elementos HTML. Ahora tenemos acceso a otro método llamado onClick, que toma una función que es llamada cada vez que en su elemento se hace clic. Dentro de esta función pasamos this.setState, y lo que setState tomará es un objeto {} con todas las propiedades que queremos cambiar en nuestro state (estado), así como los valor nuevo que deseamos insertar. \n  }\n// fecth() es una función nativa de javascript que nos permite realizar una solicitud de extracción en la URL introducida, realizar una solicitud API a esa URL, y lo que fetch() nos regresará será una promesa 'promise'. Una promesa es comunmente definida como un proxy para un valor que eventualmente estará disponible. Una vez qe una promsea ha sido llamada, comenzará en un 'estado pendiente'. Esa promesa nos dará una respuesta 'reponse' del 'body' actual de nuestra respuesta. Como queremos este body en un formato que nuestro JavaScript entienda haremos uso de un método json() para obtener como respuesta un body en este formato. \n  componentDidMount() {\n    fetch('https://jsonplaceholder.typicode.com/users').then(response => response.json()).then(users => this.setState({monsters:users}));\n  }\n\n  handleChange = (e) => {\n    this.setState({searchField:e.target.value});\n  }\n\n  //response.json() nos regresa una promesa, ya que se espera a que cargue el body de la API, tomar en cuenta que cuando veamos que se hace uso del keyword 'then' en cualquier codigo JavaScript esta es una función asíncrona usando 'promise'. Tomamos los usuarios que recibimos de response.json y lo configuramos 'monsters' con ese arreglo\n\n  //Una vez importado nuestro componente Cardlist podemos hacer uso de ello por medio de un tag, CardList, aqui, será cualquier parámetro (props, en su inicialización en su documento) que pasemos en CardList. Prop será un objeto de cualquer propiedad que se escriba o declare en el componente donde sea usado. (card-list.component.js == H2) Children será aquello que pasemos entre brackets del componente que es llamado (H3). Ahora en lugar de pasar un string en <CardList> pasaremos todos nuestros elementos 'monsters'. Recordemos que .map() generará la lista de <h1> de la misma manera, pero después los pondra como Children entre el div de card-list.component.js donde tenemos nuestro componente CardList. \n  \n  // render() {\n  //   return (\n  //     <div className=\"App\">\n  //     <CardList name='Izcoatl'> \n  //       {this.state.monsters.map(monster => (\n  //         <h1 key={monster.id}> {monster.name}</h1>\n  //       ))}\n  //     </CardList>\n  //   </div>\n  //   );\n\n  //Por ahora App.js esta siendo responsable de iterar sobre la lista de 'monsters' y, despues con base a ello, crear los elementos. Sin embargo queremos darle esa responsabilidad a nuestro componente CardList, ya que debería ser responsable de enlistar las cartas. Pasaremos monsters como un 'prop' de nuestro componente App. Después moveremos nuestro codigo donde llamamos map() al componente CardList (G1)\n\n  //Cuando usamos el elemento input debemos recordar que requiere un atributo 'type' que determinará el tipo de caja de busqueda que será (password, etc). Con el tipo 'search' podemos hacer uso de otro atributo 'placeholder' que nos permitirá poner un string en la caja aun cuando no hemos escrito nada. Ahora lo que tenemos que hacer es poder tomar control cada vez que el usuario escribe algo en la entrada, ya que queremos almacenar ese string en nuestro state, y al almacenarlo en nuestro state podemos usarlo para poder filtrar nuestros monstruos (KK1). Dentro de input podemos hacer uso de onChange, este es un método que 'dispara' con un evento sintético, que en esencia es solo un evento en nuestro navegador cada vez que el input es modificado (cuando se escribe o borra algo). Pasamos una función en onChange, donde, en este caso, e representa el evento sintético (en un aspecto mas general ejecutará onChange con cualquier función que pasemos). Si imprimimos en la consola nuestro evento sintético observaremos que es un objeto enorme con muchos campos, ya que es un evento nativo que el navegador usa para hacer todo tipo de cosas.\n\n  render() {\n    const { monsters, searchField} = this.state;\n    const filteredMonsters = monsters.filter(monster => monster.name.toLowerCase().includes(searchField.toLowerCase()));\n    return (\n      <div className=\"App\">\n        <h1>Monsters Rolodex</h1>\n        <SearchBox \n          placeholder='search monsters'\n          handleChange={this.handleChange}\n        />\n        <CardList monsters={filteredMonsters}> \n          \n        </CardList>\n    </div>\n    );\n  }\n} //Para renderizar nuestro string que hemos declarado como propiedad, dentro de nuestro HTML, tomamos la sintaxis de JSX para uso de javascript dentro de HTML, y escribiremos this.state.string\n\n//Si queremos renderizar multiples propiedades que conforman un objeto en state podemos hacer uso del método de arreglo \"map()\". map nos regresará el valor que, de igual manera, nos regresará la función que pasemos dentro de este método, iterándo esta función sobre cada uno de los elementos en el arreglo. Con base en esto, map() toma una función donde el primer argumento será el elemento actual en el que esta función será llamada. Al hacer esto siempre debemos agregar una \"llave\" única a cada \"child\" (o hijo) que es regresado por medio de map(). Debemos proveer algo que sea completamente único a esta lista de elementos en nuestro objeto propiedad en state.  \n\n//La razón por la que queremos una llave única es porque React necesita saber qué elemento necesita actualizar si unos de los elementos en el arreglo cambia\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react'; //Esta librería nos permite escribir en sintaxis de HTML dentro de un archivo JavaScript \nimport ReactDOM from 'react-dom'; //Esta libreria permite interactuar con el DOM\nimport './index.css';\nimport App from './App'; //Se importa la función de nombre App desde App.js\nimport reportWebVitals from './reportWebVitals';\n\n//Esta es una librería ReactDOM que llama la función render, la cual renderiza nuestra función App de manera que se muestra como un tag de HTML \nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n); //Lo que document.getElementById('root') esta haciendo aqui es que esta buscando en el documento un elemento con el Id de root para reemplazarlo con todo el HTML de nuestra función App, este div con el Id de root se encuentra en index.html. Con esto podemos decir que en esta ubicación -del tag div con id root- inyectaremos nuestra aplicación de React (es decir, reemplazaremos lo que sea que hay en ese tag con nuestra aplicación React)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}